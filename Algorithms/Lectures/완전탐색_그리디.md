### 완전 탐색 / 그리디 
---
+ 재귀적 알고리즘의 특성을 이해하고 이를 구현하기 위한 재귀 호출 학습
+ 조합적 문제에 대한 완전 탐색 방법
  - 순열, 조합, 부분집합 생성 알고리즘
+ 완전 탐색을 통한 문제 해결 학습
+ 탐욕 알고리즘 기법의 개념과 특성

#### 반복과 재귀
---
+ 반복(Iteration)과 재귀(Recursion)
  - 반복은 수행하는 작업이 완료될 때까지 계속 반복
  - 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용
    - 하나의 큰 문제를 해결할 수 있는 (해결하기 쉬운) 더 작은 문제로 쪼개고 그 결과를 결합
    - 재귀함수로 구현

+ 반복의 예제 (선택 정렬)
    ```c++
    void selectionSort(int arr[], int n){
        for(int i=; i<n-1; i++){
            int min = i;
            for(int j= i + 1; j < n; j++){
                if(arr[j] < arr[min]) min = j;
            }
            int temp = arr[min];
            arr[min] = arr[i];
            arr[i] = temp;
        }
    }
    ```

+ 재귀 알고리즘
  - 해결하려는 문제를 작은 단위로 나누어 동일한 알고리즘을 반복적으로 적용하여 최종 해를 구하는 알고리즘
  - 두 부분으로 나뉜다
    - 하나 또는 그 이상의 기본 경우 (Base case: 기저 사례)
        - 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드 역할, **재귀 함수를 종료하는 부분**
    - 하나 또는 그 이상의 유도된 경우 (Inductive part)
        - 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법, **재귀 함수를 호출하는 부분**

+ 재귀 함수 작성 절차
    - 더 작은 문제로 표현 시도
    - 문제를 직접 풀 수 있는 것이 어떤 경우인지 Base Case 확인
    - N이 줄어서 Base Case를 만나게 되는지 확인
    - 두 부분으로 나누어서 코드 작성(Base Case + Induction Part)

+ 재귀 함수의 비효율성
    - 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다. 따라서 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하 발생

+ 재귀의 예제 (Factorial)
    > Base Part: N<=1인 경우, N=1

    > Induction Part: N>1, N! = N X (N-1)!
    
    ```c++
    int fact(int n)
    {
        if(n<=1){
            return 1;
        }
        else{
            return n*fact(n-1);
        }
    }
    ```

+ 반복 또는 재귀?
    - 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택
    - 문제에 따라 재귀적 구현이 간단하고 자연스러운 경우가 있다

        ||재귀|반복|
        |------|---|---|
        |종료|재귀 함수 호출이 종료되는 기저 사례|반복문의 종료 조건|
        |수행 시간|(상대적)느림|(상대적)빠름|
        |메모리 공간|(상대적)많이 사용)|적게 사용|
        |소스 코드 길이|짧고 간결|길다|
        |소스 코드 형태|선택 구조|반복 구조(for, while)|
        |무한 반복 시|스택 오버플로우|CPU 반복 점유|

    - 수행 시간과 메모리의 경우, 동일 시간 복잡도 기준의 비교
    - 분할정복기법과 같은 방식을 사용한다면 재귀가 더 효율적일 수 있다.


+ 거듭 제곱 연산에 대한 재귀와 반복
    ```c++
    int recursivePower(int x, int n){
        if(n==0) return 1;
        if(n==1) return x;
        return x * recursivePower(x, n-1);
    }
    ```
    ```c++
    int iterativePower(int x, int n){
        int ret = 1;
        for(int i=0; i<n; i++){
            ret = ret * x;
        }
        return ret;
    }
    ```

#### 조합적 문제
---
+ TSP 문제(Traveling Salesman Problem)
    - 모든 도시들을 한번씩 방문하는데 필요한 최소 비용 구하기
    - 그래프는 완전 그래프로 주어진다. (모든 노드에서 다른 모든 노드 간에 간선이 존재)
    - 시작점은 정해져있지 X 
    - 0, 1, 2 3개의 도시를 방문한다고 했을 때 그 순서가 비용에 영향을 미친다

+ 순열 (Permutation)
    - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
    - 서로 다른 n개 중 r개를 택하는 순열을 nPr로 표현한다.
    - nPr = n*(n-1)*(n-2)*...*(n-(r-1))
    - n!은 nPn
    - **n > 12인 경우, 시간 복잡도가 폭발적으로 증가**

+ TSP 문제에 대한 재귀호출 + 순열 풀이
    ```c++
    int solve(int pos, int visited){
        if(visited == (1 << N) - 1){ // 10000 - 1 -> 1111
            return 0;
        }
        int ret = INF;
        for(int next=0; next < N; next++){
            // 방문 여부와 엣지가 있는지 확인
            if(!(visited & (1 << next)) && Graph[pos][next]){
                // 방문 처리를 해줌으로써 문제의 범위를 줄이는 부분
                int tmp = Graph[pos][next] + solve(next, visited | (1 << next));
                if(tmp < ret)){
                    ret = tmp;
                }
            }
        }
        return tmp;
    }
    ```
    + visited을 불린형 배열이 아닌 비트마스크로 처리한 이유?
    + 메모이제이션을 위한 visited 활용이 가능해진다.
        - int Memo[N][1<<N]
        - N: 선택의 최대 갯수, 1 << N : 비트마스크의 최대 범위
        - solve 내 전달되는 파라미터들을 메모이제이션을 위한 배열의 인덱스로 사용한다.
        - 계산 결과를 Memo에 저장해두고, 완전탐색시 중복계산에 대해서는 탐색을 진행하지 않는 방식으로 활용 가능

#### 조합
---
+ 서로 다른 n개의 원소 중 r개를 **순서** 없이 골라낸 것을 조합(Combination)이라고 부른다.
+ nCr = n!/((n-r)!r!) (n>=r)
+ nCr = n-1Cr-1 + n-1Cr
+ nC0 = 1
    - nPr = nCr * rPr
    - nCr = nPr/rPr = (n*(n-1)*...*(n-r+1))/r! = n!/((n-r)!r!)

+ 조합으로 풀어야 하는 문제를 순열로 풀게 되면 문제에서 주어진 제약 시간 조건을 넘기는 경우가 있다.
+ 순열 or 조합?
    - 선택의 순서가 결과에 영향을 주는 경우 : 순열
    - 선택의 순서가 결과에 영향을 주지 않는 경우 : 조합

+ 예제
    - {1, 2, 3, 4} 4개의 숫자가 주어졌을 때, 2개를 붙여서 만들 수 있는 최대 수는 얼마인가? -> 순열
        - 2와 3을 골랐을 때, 23과 32는 다른 경우에 속하기 때문
    - {1, 2, 3, 4} 4개의 숫자가 주어졌을 때, 2개를 더해서 만들 수 있는 최대 값은 얼마인가? -> 조합
        - 2와 3을 골랐을 때, 순서와 관계없이 합은 동일하기 때문
    - 조합 문제를 순열로도 풀 수 있지만, 문제에서 주어지는 제한시간을 초과할 가능성이 크다
    - 아니면 순열로 풀고, 가지치기/메모이제이션을 통해 시간 안에 들어오게 만들 수도 있기는 하다.
    
+ 순열: 2개를 골라서 만들 수 있는 최대 수 - 재귀 예제
    ```c++
    int solve(int cnt, int used, int val){
        if(cnt==2){
            return val;
        }
        int ret = 0;
        for(int i=0; i<N; i++){
            if(used & (1 << i)) continue;
            int tmp = solve(cnt + 1, used | (1 << i), val * 10 + Nums[i]);
            if(tmp > ret) ret = temp;
        }
        return ret;
    }
    ```
+ 조합: 2개를 더해서 만들 수 있는 최대 수 - 재귀 예제
    ```c++
    int solve(int pos, int cnt, int val){
        if(cnt==2) return val;
        if(pos==N) return -1; 
        // 계속 선택을 안하는 분기의 경우, 카운트가 2가 차지 못하고 모든 수를 본 상태
        // 잘못된 경우이므로 절대 해가 될 수 없는 임의의 값을 반환하도록 처리한다.

        int ret = 0; int tmp;
        tmp = solve(pos + 1, cnt + 1, val + Nums[pos]);
        if(tmp > ret) ret = temp;
        tmp = solve(pos + 1, cnt, val);
        if(tmp > ret) ret = tmp;

        return ret;
    }
    ```
    + 부분집합 문제와 유사하다고 생각할 수 있다. {1, 2, 3, 4} 있을 때, 만들 수 있는 부분집합 중 원소의 갯수가 2개인 경우에만 합을 구해서 최댓값을 찾는 문제
        ```c++
        int countBits(int value){
            int cnt = 0;
            while(value > 0){
                if((value & 1) == 1) cnt++;
                value = value >> 1;
            }
            return cnt;
        }
        int solve(){
            int ret = 0;
            for(int i=0; i < (1 << N); i++){
                if(countBits(i) == 2){
                    int sum = 0;
                    for(int j=0; j<N; j++){
                        if(i & 1 << j)){
                            sum += Nums[j];
                        }
                    }
                    if(sum > ret) ret = sum;
                }
            }
        }
        ```

#### 완전 탐색 기법
---
+ 예제 문제: Baby-gin Game
    - 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때,
        - 3장의 카드가 연속적인 번호를 갖는 경우를 run,
        - 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
        - 6장의 카드가 run과 triplet으로만 구성된 경우를 baby-gin이라고 한다
        - 6개의 숫자가 주어졌을 때, baby-gin인지 판단해보자
    - 모든 숫자의 배열 순서를 순열로 따져본 후에 앞3/뒤3 숫자로 판단하면 가능하다.
    - 해당 숫자에 대해서 모든 배열 순서를 보면서, 한번 이상만 베이비진으로 판단되면 베이비진인 것!
    ```c++
    int solve(int arr[], int pos, int used){
    // arr: 중간 과정에 숫자를 나열한 결과를 저장하는 임시 변수(포인터가 넘어가는 것)
    // pos: 몇 번째 숫자를 선택할 것인가
    // used: 어떤 숫자가 사용되었는가
        if(pos == 6){
            int tri = 0; int run = 0;
            for(int i=0; i<2; i++){
                if(arr[i*3+1] == arr[i*3]+1 && arr[i*3+2] == arr[i*3+1]+1){
                    ++run;
                }
                else if(arr[i*3+1] == arr[i*3] && arr[i*3+2] == arr[i*3+1]){
                    ++tri;
                }
            }
            if(run + tri == 2) return 1;

            return 0;
        }
        for(int i=0; i<6; i++){
            if(used & (1 << i)) continue;
            arr[pos] = Nums[i];
            if(solve(arr, pos + 1, used | (1 << i))) return 1;
            // 중간쯤에 베이비진 여부가 판단되었으면, 그냥 바로 리턴해버린다. (더 탐색할 필요가 없으므로)
        }
        return 0;
    }
    ```

+ 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것이다
+ 또한, 이들은 전형적으로 순열, 조합, 그리고 부분집합과 같은 조합적 문제들(Combinational Problems)과 연관된다
+ 완전 탐색은 조합적 문제에 대한 Brute-Force 방법이다.

#### 탐욕 알고리즘
---
