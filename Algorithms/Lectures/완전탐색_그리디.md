### 완전 탐색 / 그리디 
---
+ 재귀적 알고리즘의 특성을 이해하고 이를 구현하기 위한 재귀 호출 학습
+ 조합적 문제에 대한 완전 탐색 방법
  - 순열, 조합, 부분집합 생성 알고리즘
+ 완전 탐색을 통한 문제 해결 학습
+ 탐욕 알고리즘 기법의 개념과 특성

#### 반복과 재귀
---
+ 반복(Iteration)과 재귀(Recursion)
  - 반복은 수행하는 작업이 완료될 때까지 계속 반복
  - 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용
    - 하나의 큰 문제를 해결할 수 있는 (해결하기 쉬운) 더 작은 문제로 쪼개고 그 결과를 결합
    - 재귀함수로 구현

+ 반복의 예제 (선택 정렬)
    ```c++
    void selectionSort(int arr[], int n){
        for(int i=; i<n-1; i++){
            int min = i;
            for(int j= i + 1; j < n; j++){
                if(arr[j] < arr[min]) min = j;
            }
            int temp = arr[min];
            arr[min] = arr[i];
            arr[i] = temp;
        }
    }
    ```

+ 재귀 알고리즘
  - 해결하려는 문제를 작은 단위로 나누어 동일한 알고리즘을 반복적으로 적용하여 최종 해를 구하는 알고리즘
  - 두 부분으로 나뉜다
    - 하나 또는 그 이상의 기본 경우 (Base case: 기저 사례)
        - 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드 역할, **재귀 함수를 종료하는 부분**
    - 하나 또는 그 이상의 유도된 경우 (Inductive part)
        - 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법, **재귀 함수를 호출하는 부분**

+ 재귀 함수 작성 절차
    - 더 작은 문제로 표현 시도
    - 문제를 직접 풀 수 있는 것이 어떤 경우인지 Base Case 확인
    - N이 줄어서 Base Case를 만나게 되는지 확인
    - 두 부분으로 나누어서 코드 작성(Base Case + Induction Part)

+ 재귀 함수의 비효율성
    - 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다. 따라서 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하 발생

+ 재귀의 예제 (Factorial)
    > Base Part: N<=1인 경우, N=1

    > Induction Part: N>1, N! = N X (N-1)!
    
    ```c++
    int fact(int n)
    {
        if(n<=1){
            return 1;
        }
        else{
            return n*fact(n-1);
        }
    }
    ```

+ 반복 또는 재귀?
    - 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택
    - 문제에 따라 재귀적 구현이 간단하고 자연스러운 경우가 있다

        ||재귀|반복|
        |------|---|---|
        |종료|재귀 함수 호출이 종료되는 기저 사례|반복문의 종료 조건|
        |수행 시간|(상대적)느림|(상대적)빠름|
        |메모리 공간|(상대적)많이 사용)|적게 사용|
        |소스 코드 길이|짧고 간결|길다|
        |소스 코드 형태|선택 구조|반복 구조(for, while)|
        |무한 반복 시|스택 오버플로우|CPU 반복 점유|

    - 수행 시간과 메모리의 경우, 동일 시간 복잡도 기준의 비교
    - 분할정복기법과 같은 방식을 사용한다면 재귀가 더 효율적일 수 있다.


+ 거듭 제곱 연산에 대한 재귀와 반복
    ```c++
    int recursivePower(int x, int n){
        if(n==0) return 1;
        if(n==1) return x;
        return x * recursivePower(x, n-1);
    }
    ```
    ```c++
    int iterativePower(int x, int n){
        int ret = 1;
        for(int i=0; i<n; i++){
            ret = ret * x;
        }
        return ret;
    }
    ```

#### 조합적 문제
---
+ TSP 문제(Traveling Salesman Problem)
    - 모든 도시들을 한번씩 방문하는데 필요한 최소 비용 구하기
    - 그래프는 완전 그래프로 주어진다. (모든 노드에서 다른 모든 노드 간에 간선이 존재)
    - 시작점은 정해져있지 X 
    - 0, 1, 2 3개의 도시를 방문한다고 했을 때 그 순서가 비용에 영향을 미친다

+ 순열 (Permutation)
    - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
    - 서로 다른 n개 중 r개를 택하는 순열을 nPr로 표현한다.
    - nPr = n*(n-1)*(n-2)*...*(n-(r-1))
    - n!은 nPn
    - **n > 12인 경우, 시간 복잡도가 폭발적으로 증가**

+ TSP 문제에 대한 재귀호출 + 순열 풀이
    ```c++
    int solve(int pos, int visited){
        if(visited == (1 << N) - 1){ // 10000 - 1 -> 1111
            return 0;
        }
        int ret = INF;
        for(int next=0; next < N; next++){
            // 방문 여부와 엣지가 있는지 확인
            if(!(visited & (1 << next)) && Graph[pos][next]){
                // 방문 처리를 해줌으로써 문제의 범위를 줄이는 부분
                int tmp = Graph[pos][next] + solve(next, visited | (1 << next));
                if(tmp < ret)){
                    ret = tmp;
                }
            }
        }
        return tmp;
    }
    ```
    + visited을 불린형 배열이 아닌 비트마스크로 처리한 이유?
    + 메모이제이션을 위한 visited 활용이 가능해진다.
        - int Memo[N][1<<N]
        - N: 선택의 최대 갯수, 1 << N : 비트마스크의 최대 범위
        - solve 내 전달되는 파라미터들을 메모이제이션을 위한 배열의 인덱스로 사용한다.
        - 계산 결과를 Memo에 저장해두고, 완전탐색시 중복계산에 대해서는 탐색을 진행하지 않는 방식으로 활용 가능

#### 조합
---
+ 서로 다른 n개의 원소 중 r개를 **순서** 없이 골라낸 것을 조합(Combination)이라고 부른다.
+ nCr = n!/((n-r)!r!) (n>=r)
+ nCr = n-1Cr-1 + n-1Cr
+ nC0 = 1
    - nPr = nCr * rPr
    - nCr = nPr/rPr = (n*(n-1)*...*(n-r+1))/r! = n!/((n-r)!r!)

+ 조합으로 풀어야 하는 문제를 순열로 풀게 되면 문제에서 주어진 제약 시간 조건을 넘기는 경우가 있다.
+ 순열 or 조합?
    - 선택의 순서가 결과에 영향을 주는 경우 : 순열
    - 선택의 순서가 결과에 영향을 주지 않는 경우 : 조합

+ 예제
    - {1, 2, 3, 4} 4개의 숫자가 주어졌을 때, 2개를 붙여서 만들 수 있는 최대 수는 얼마인가? -> 순열
        - 2와 3을 골랐을 때, 23과 32는 다른 경우에 속하기 때문
    - {1, 2, 3, 4} 4개의 숫자가 주어졌을 때, 2개를 더해서 만들 수 있는 최대 값은 얼마인가? -> 조합
        - 2와 3을 골랐을 때, 순서와 관계없이 합은 동일하기 때문
    - 조합 문제를 순열로도 풀 수 있지만, 문제에서 주어지는 제한시간을 초과할 가능성이 크다
    - 아니면 순열로 풀고, 가지치기/메모이제이션을 통해 시간 안에 들어오게 만들 수도 있기는 하다.
    
+ 순열: 2개를 골라서 만들 수 있는 최대 수 - 재귀 예제
    ```c++
    int solve(int cnt, int used, int val){
        if(cnt==2){
            return val;
        }
        int ret = 0;
        for(int i=0; i<N; i++){
            if(used & (1 << i)) continue;
            int tmp = solve(cnt + 1, used | (1 << i), val * 10 + Nums[i]);
            if(tmp > ret) ret = temp;
        }
        return ret;
    }
    ```
+ 조합: 2개를 더해서 만들 수 있는 최대 수 - 재귀 예제
    ```c++
    int solve(int pos, int cnt, int val){
        if(cnt==2) return val;
        if(pos==N) return -1; 
        // 계속 선택을 안하는 분기의 경우, 카운트가 2가 차지 못하고 모든 수를 본 상태
        // 잘못된 경우이므로 절대 해가 될 수 없는 임의의 값을 반환하도록 처리한다.

        int ret = 0; int tmp;
        tmp = solve(pos + 1, cnt + 1, val + Nums[pos]);
        if(tmp > ret) ret = temp;
        tmp = solve(pos + 1, cnt, val);
        if(tmp > ret) ret = tmp;

        return ret;
    }
    ```
    + 부분집합 문제와 유사하다고 생각할 수 있다. {1, 2, 3, 4} 있을 때, 만들 수 있는 부분집합 중 원소의 갯수가 2개인 경우에만 합을 구해서 최댓값을 찾는 문제
        ```c++
        int countBits(int value){
            int cnt = 0;
            while(value > 0){
                if((value & 1) == 1) cnt++;
                value = value >> 1;
            }
            return cnt;
        }
        int solve(){
            int ret = 0;
            for(int i=0; i < (1 << N); i++){
                if(countBits(i) == 2){
                    int sum = 0;
                    for(int j=0; j<N; j++){
                        if(i & 1 << j)){
                            sum += Nums[j];
                        }
                    }
                    if(sum > ret) ret = sum;
                }
            }
        }
        ```

#### 완전 탐색 기법
---
+ 예제 문제: Baby-gin Game
    - 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때,
        - 3장의 카드가 연속적인 번호를 갖는 경우를 run,
        - 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
        - 6장의 카드가 run과 triplet으로만 구성된 경우를 baby-gin이라고 한다
        - 6개의 숫자가 주어졌을 때, baby-gin인지 판단해보자
    - 모든 숫자의 배열 순서를 순열로 따져본 후에 앞3/뒤3 숫자로 판단하면 가능하다.
    - 해당 숫자에 대해서 모든 배열 순서를 보면서, 한번 이상만 베이비진으로 판단되면 베이비진인 것!
    ```c++
    int solve(int arr[], int pos, int used){
    // arr: 중간 과정에 숫자를 나열한 결과를 저장하는 임시 변수(포인터가 넘어가는 것)
    // pos: 몇 번째 숫자를 선택할 것인가
    // used: 어떤 숫자가 사용되었는가
        if(pos == 6){
            int tri = 0; int run = 0;
            for(int i=0; i<2; i++){
                if(arr[i*3+1] == arr[i*3]+1 && arr[i*3+2] == arr[i*3+1]+1){
                    ++run;
                }
                else if(arr[i*3+1] == arr[i*3] && arr[i*3+2] == arr[i*3+1]){
                    ++tri;
                }
            }
            if(run + tri == 2) return 1;

            return 0;
        }
        for(int i=0; i<6; i++){
            if(used & (1 << i)) continue;
            arr[pos] = Nums[i];
            if(solve(arr, pos + 1, used | (1 << i))) return 1;
            // 중간쯤에 베이비진 여부가 판단되었으면, 그냥 바로 리턴해버린다. (더 탐색할 필요가 없으므로)
        }
        return 0;
    }
    ```

+ 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것이다
+ 또한, 이들은 전형적으로 순열, 조합, 그리고 부분집합과 같은 조합적 문제들(Combinational Problems)과 연관된다
+ 완전 탐색은 조합적 문제에 대한 Brute-Force 방법이다.

#### 탐욕 알고리즘
---
##### 예제 문제 1. 거스름돈
    - 손님이 지불한 금액에서 물건 값을 제한 차액을 지불하는 문제
    - 어떻게하면 거스름돈으로 주는 지폐와 동전의 갯수를 최소한으로 줄일 수 있을까?

+ 탐욕 알고리즘
    - 최적해를 구하는 데 사용되는 근시안적인 방법
    - 여러 경우 중 하나를 선택할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행
    - 각 선택 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, **그것이 최적이라는 보장은 없다.**

+ 탐욕 기법을 이용한 거스름돈 줄이기
    - 해 선택: 단위가 가장 큰 동전으로만 거스름돈을 준다
    - 거스름돈이 800원이라고 치면,
        |Case 1|Case 2|
        |---|---|
        |500, 100, 50, 10|500, 400, 100, 50, 10|
        |500원 1개, 100원 3개|500원 1개, 100원 3개|
        |최적임|최적이 아님 (400원 2개의 코인으로 가능)|

##### 예제문제 2. 배낭 짐싸기(Knapsack)
    - 도둑은 부자들의 값진 물건을 훔치기 위해 보관 창고에 침입하였다.
    - 훔친 물건을 배낭에 담아 올 계획이다. 배낭은 담을 수 있는 물건의 총 무게가 정해져 있다.
    - 창고에는 N개의 물건이 있고, 각각의 물건에는 무게와 값이 정해져 있다.
    - 배낭이 수용할 수 있는 무게를 초과하지 않으면서 가장 큰 가치만큼 배낭에 담아야 한다.

+ Knapsack 문제 유형
    - 0-1 Knapsack
        - 배낭에 물건을 통째로 담아야 하는 문제
        - 물건을 쪼갤 수 없는 경우

    - Fractional Knapsack
        - 물건을 부분적으로 담는 것이 허용되는 문제
        - 물건을 쪼갤 수 있는 경우
    
+ 0-1 Knapsack 문제에 대한 완전 탐색 방법
    - 물건들의 집합 S에 대한 모든 부분 집합을 구한다
    - 물건들의 합이 총 W가 넘는 부분 집합은 버리고, 나머지 집합에서 총 값이 가장 큰 집합 선택
    - 물건의 개수가 증가하면 시간복잡도가 지수적으로 증가한다
        - 크기 N인 부분합의 수 = 2^N
    
+ 0-1 Knapsack 문제에 대한 탐욕적 방법
    1. 값이 비싼 물건부터 채운다 -> 최적이 아니다
    2. 무게가 가벼운 물건부터 채운다 -> 최적이 아니다
    3. 단위 무게 당 값이 높은 순서로 물건을 채운다 -> 최적이 아니다

+ Fractional Knapsack 문제에 대한 탐욕적 방법
    - 물건의 일부를 잘라서 담을 수 있으면, 단위 무게 당 값이 높은 순서로 물건을 채우면 최적이다.

##### 예제 문제 3. 회의실 배정하기
    - 김대리는 소프트웨어 개발팀들의 회의실 사용 신청을 처리하는 업무를 한다. 이번 주 금요일에 사용 가능한 회의실은 하나만 존재하고 다수의 회의가 신청된 상태이다.
    - 회의는 시작 시간과 종료 시간이 있으며, 회의 시간이 겹치는 회의들은 동시에 열릴 수 없다.
    - 최대 몇 개의 회의를 배정할 수 있을까?
    - 입력 예
        - 회의 개수
        - (시작시간, 종료시간)

+ 회의실 배정하기 문제에 대한 탐욕적 방법
    1. 회의 시간이 짧은 것부터 우선적으로 배정 -> 최적이 아니다
        - 반례
        ```
        ---------- -----------
                 ---
        ```
    2. 회의가 가장 일찍 끝나는 것부터 우선적으로 배정 -> 최적이다.
        - 회의 목록 S에서 가장 일찍 끝나는 회의 a를 선택한다
        - a와 겹치는 모든 회의를 S에서 삭제한다
        - S에 회의가 모두 없어질 때까지 반복한다.

+ 정당성 증명
    - 탐욕적 선택이 항상 최적해로 가는 길 중에 하나이다
    - 즉, 가장 종료시간이 빠른 회의를 포함하는 최적해가 반드시 존재한다.
    - a가 속하지 않는 최적해가 있다고 가정해보자.
        ```
        --- -> 얘를 빼고 a를 넣을 수 있을까? 항상 넣을 수 있다
            ---
                ---
        ```
        - 가장 일찍 끝나는 회의로 대체한 것도 최적해중에 하나이다 (배정된 회의 갯수는 동일하므로)

+ 종료시간을 기준으로 정렬해두면, S에서 굳이 제거할 필요도 없다.
    ```c++
    struct meeting_type {
        int start;
        int end;
    };
    int solve(){
        int lastend = 0, cnt = 0;
        for(int i=0; i<N; i++){
            if(Meetings[i].start < lastEnd) continue;
            printf("(%d,%d)\n", Meetings[i].start, Meetings[i].end);
            lastEnd = Meetings.end;
            ++cnt;
        }
        return cnt;
    }
    ```

+ Baby-Gin 문제를 완전탐색이 아닌 방법으로 풀어보자
    - 0~9 번호별 카드의 개수를 counts 배열에 센다.
    - counts 배열의 각 원소를 체크하여 run / triplet을 확인하여 Baby-Gin 여부를 판단한다.
    - run을 확인하기 위해서는, 기준점에서 연속된 3개가 1이상으로 차있는지 확인
        - run이 있다면 지워주고, triplet 확인
    - triplet을 확인하기 위해서는, 3 이상인지 확인
    - run과 triplet 중에서 어떤 것을 먼저 확인해야 하나? (**탐욕 방법**)
        - run을 먼저 조사하면 답을 찾지 못하는 경우가 발생할 수 있다.
        - Ex) 333456 중에 345을 run으로 판단
    - triple을 먼저 판단해야 한다.
    ```c++
    int solve(){
        int tri = 0, run = 0;
        for(int i=0; i<10;){
            if(Cnt[i] >= 3){
                Cnt[i] -= 3;
                tri++;
            }
            else if(i <= 7 && Cnt[i] >= 1 && Cnt[i+1] >= 1 && Cnt[i+2] >= 1){
                Cnt[i]--;
                Cnt[i+1]--;
                Cnt[i+2]--;
                run++;
            }
            else{
                ++i;
            }
        }
    }
    ```