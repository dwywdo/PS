### 완전 탐색 / 그리디 
---
+ 재귀적 알고리즘의 특성을 이해하고 이를 구현하기 위한 재귀 호출 학습
+ 조합적 문제에 대한 완전 탐색 방법
  - 순열, 조합, 부분집합 생성 알고리즘
+ 완전 탐색을 통한 문제 해결 학습
+ 탐욕 알고리즘 기법의 개념과 특성

#### 반복과 재귀
---
+ 반복(Iteration)과 재귀(Recursion)
  - 반복은 수행하는 작업이 완료될 때까지 계속 반복
  - 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용
    - 하나의 큰 문제를 해결할 수 있는 (해결하기 쉬운) 더 작은 문제로 쪼개고 그 결과를 결합
    - 재귀함수로 구현

+ 반복의 예제 (선택 정렬)
    ```c++
    void selectionSort(int arr[], int n){
        for(int i=; i<n-1; i++){
            int min = i;
            for(int j= i + 1; j < n; j++){
                if(arr[j] < arr[min]) min = j;
            }
            int temp = arr[min];
            arr[min] = arr[i];
            arr[i] = temp;
        }
    }
    ```

+ 재귀 알고리즘
  - 해결하려는 문제를 작은 단위로 나누어 동일한 알고리즘을 반복적으로 적용하여 최종 해를 구하는 알고리즘
  - 두 부분으로 나뉜다
    - 하나 또는 그 이상의 기본 경우 (Base case: 기저 사례)
        - 집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드 역할, **재귀 함수를 종료하는 부분**
    - 하나 또는 그 이상의 유도된 경우 (Inductive part)
        - 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법, **재귀 함수를 호출하는 부분**

+ 재귀 함수 작성 절차
    - 더 작은 문제로 표현 시도
    - 문제를 직접 풀 수 있는 것이 어떤 경우인지 Base Case 확인
    - N이 줄어서 Base Case를 만나게 되는지 확인
    - 두 부분으로 나누어서 코드 작성(Base Case + Induction Part)

+ 재귀 함수의 비효율성
    - 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다. 따라서 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하 발생

+ 재귀의 예제 (Factorial)
    > Base Part: N<=1인 경우, N=1

    > Induction Part: N>1, N! = N X (N-1)!
    
    ```c++
    int fact(int n)
    {
        if(n<=1){
            return 1;
        }
        else{
            return n*fact(n-1);
        }
    }
    ```

+ 반복 또는 재귀?
    - 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택
    - 문제에 따라 재귀적 구현이 간단하고 자연스러운 경우가 있다

        ||재귀|반복|
        |------|---|---|
        |종료|재귀 함수 호출이 종료되는 기저 사례|반복문의 종료 조건|
        |수행 시간|(상대적)느림|(상대적)빠름|
        |메모리 공간|(상대적)많이 사용)|적게 사용|
        |소스 코드 길이|짧고 간결|길다|
        |소스 코드 형태|선택 구조|반복 구조(for, while)|
        |무한 반복 시|스택 오버플로우|CPU 반복 점유|

    - 수행 시간과 메모리의 경우, 동일 시간 복잡도 기준의 비교
    - 분할정복기법과 같은 방식을 사용한다면 재귀가 더 효율적일 수 있다.


+ 거듭 제곱 연산에 대한 재귀와 반복
    ```c++
    int recursivePower(int x, int n){
        if(n==0) return 1;
        if(n==1) return x;
        return x * recursivePower(x, n-1);
    }
    ```
    ```c++
    int iterativePower(int x, int n){
        int ret = 1;
        for(int i=0; i<n; i++){
            ret = ret * x;
        }
        return ret;
    }
    ```

#### 조합적 문제
---
+ TSP 문제(Traveling Salesman Problem)
    - 모든 도시들을 한번씩 방문하는데 필요한 최소 비용 구하기
    - 그래프는 완전 그래프로 주어진다. (모든 노드에서 다른 모든 노드 간에 간선이 존재)
    - 시작점은 정해져있지 X 
    - 0, 1, 2 3개의 도시를 방문한다고 했을 때 그 순서가 비용에 영향을 미친다

+ 순열 (Permutation)
    - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
    - 서로 다른 n개 중 r개를 택하는 순열을 nPr로 표현한다.
    - nPr = n*(n-1)*(n-2)*...*(n-(r-1))
    - n!은 nPn
    - **n > 12인 경우, 시간 복잡도가 폭발적으로 증가**

+ TSP 문제에 대한 재귀호출 + 순열 풀이
    ```c++
    int solve(int pos, int visited){
        if(visited == (1 << N) - 1){ // 10000 - 1 -> 1111
            return 0;
        }
        int ret = INF;
        for(int next=0; next < N; next++){
            // 방문 여부와 엣지가 있는지 확인
            if(!(visited & (1 << next)) && Graph[pos][next]){
                // 방문 처리를 해줌으로써 문제의 범위를 줄이는 부분
                int tmp = Graph[pos][next] + solve(next, visited | (1 << next));
                if(tmp < ret)){
                    ret = tmp;
                }
            }
        }
        return tmp;
    }
    ```
    + visited을 불린형 배열이 아닌 비트마스크로 처리한 이유?
    + 메모이제이션을 위한 visited 활용이 가능해진다.
        - int Memo[N][1<<N]
        - N: 선택의 최대 갯수, 1 << N : 비트마스크의 최대 범위
        - solve 내 전달되는 파라미터들을 메모이제이션을 위한 배열의 인덱스로 사용한다.
        - 계산 결과를 Memo에 저장해두고, 완전탐색시 중복계산에 대해서는 탐색을 진행하지 않는 방식으로 활용 가능

#### 조합
---
+ 서로 다른 n개의 원소 중 r개를 **순서** 없이 골라낸 것을 조합(Combination)이라고 부른다.
+ nCr = n!/((n-r)!r!) (n>=r)
+ nCr = n-1Cr-1 + n-1Cr
+ nC0 = 1
    - nPr = nCr * rPr
    - nCr = nPr/rPr = (n*(n-1)*...*(n-r+1))/r! = n!/((n-r)!r!)

+ 조합으로 풀어야 하는 문제를 순열로 풀게 되면 문제에서 주어진 제약 시간 조건을 넘기는 경우가 있다.
+ 순열 or 조합?
    - 선택의 순서가 결과에 영향을 주는 경우 : 순열
    - 선택의 순서가 결과에 영향을 주지 않는 경우 : 조합

+ 예제
    - {1, 2, 3, 4} 4개의 숫자가 주어졌을 때, 2개를 붙여서 만들 수 있는 최대 수는 얼마인가? -> 순열
        - 2와 3을 골랐을 때, 23과 32는 다른 경우에 속하기 때문
    - {1, 2, 3, 4} 4개의 숫자가 주어졌을 때, 2개를 더해서 만들 수 있는 최대 값은 얼마인가? -> 조합
        - 2와 3을 골랐을 때, 순서와 관계없이 합은 동일하기 때문
    - 조합 문제를 순열로도 풀 수 있지만, 문제에서 주어지는 제한시간을 초과할 가능성이 크다
    - 아니면 순열로 풀고, 가지치기/메모이제이션을 통해 시간 안에 들어오게 만들 수도 있기는 하다.