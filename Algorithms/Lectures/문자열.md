### 문자열
---
    - 문자열에 대한 기본 특성을 이해한다
    - 문자열에서 패턴을 탐색하는 방법을 학습한다
    - 접미어 트리와 접미어 배열에 대해 이해하고 문자열 처리에 응용하는 방법을 학습한다
    - 대표적인 문자열 압축 방법인 Run-Length 알고리즘과 허프만(Huffman) 알고리즘에 대해 학습한다

#### 해시 (Hash)
---
+ 예제 문제: 파일 이름으로 바로 찾기
    - 대부분의 파일시스템들은 하나의 디렉토리에 존재가능한 파일의 수에 제한이 없다. 따라서, 다수의 디렉토리마다 대량의 파일들이 존재할 수 있따
    - 아래와 같은 작업들이 빈번하게 수행되는 경우를 생각해보자
        - ls
        - cd
        - find
    - 성능 저하의 원인이 된다

+ 해싱 (Hashing)
    - 특정 항목을 검색하고자 할 때, 탐색키를 이용한 산술적 연산을 이용해 키가 있는 위치를 계산하여 바로 찾는 방법
    - 해시 함수 (Hash function)
        - 탐색할 데이터를 해시값으로 변환하는 함수
    - 해시 테이블 (Hash table)
        - 해시 함수에 의해 반환된 주소의 위치에 항목을 저장한 데이터 구조
    - 해시 검색 과정
        - 해시 함수에 탐색 키를 입력하여 주소를 구하고, 구한 주소에 해당하는 해시 테이블로 이동
        - 해당 주소에 원하는 항목이 있으면 검색 성공, 아니면 실패

+ 충돌 (Collision)
    - 서로 다른 탐색키를 해시 함수에 적용하였는데, 반환된 해시 주소는 동일한 경우
    - 해시 함수가 아무리 해시 주소를 공평하게 분배한다고 해도, 해시 테이블에 저장되는 자료의 수가 증가하면서 충돌은 불가피해진다
    - 해결 방법
        - 체이닝
            - 해시 테이블의 구조를 변경하여 각 버킷에 하나 이상의 키 값을 가지는 자료가 저장될 수 있도록 하는 방법
            - 하나의 버킷에 여러 개의 키값을 저장하도록 하기 위해 연결 리스트를 활용함
        - 개방 주소법
            - 해시 함수로 구한 주소에 빈 공간이 없어 충돌이 발생하면, 그 다음 공간에 빈 공간이 있는지 조사한다
                - 빈 공간이 있으면, 탐색키에 대한 항목을 저장
                - 빈 공간이 없으면, 공간이 나올때까지 탐색을 반복

+ 문자열
    - 문자열의 분류
        - 고정 길이 문자열
        - 가변 길이 문자열 (Java에서는 length controlled, C에서는 delmited by '\0')
    - C에서의 문자열은 아스키 코드로 저장, 자바에서는 유니코드(2byte 저장)

#### 패턴 매칭
---
+ 200개의 문자로 이루어진 문자열 X안에 10개의 문자로 이루어진 문자열 Y가 존재하는지 찾아보자
+ 문제를 확장해서 X의 길이는 10000, Y의 길이가 80이라고 하면
    - 알고리즘과 시간 복잡도는?
+ 패턴 매칭에 사용되는 알고리즘
    - 고지식한 패턴 검색 알고리즘
        - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작
        - 시간 복잡도: O(NM)
    - 카프 라빈 알고리즘
        - 문자열 검색을 위해 해시 값 함수를 이용
        - 패턴 내의 문자들을 일일이 비교하는 대신에 패턴의 해시 값과 본문 안에 있는 하위 문자열의 해시 값만을 비교
        - 최악의 시간복잡도는 O(NM)이지만 평균적으로는 선형에 가까운 빠른 속도를 가짐
        - 처음 해시값을 구할 때에는 문자열에서 패턴 길이 만큼 읽어서 구한다
        - 해시 충돌이 발생할 수 있으므로 해시 일치 시 문자열 일치를 한번 더 검사
    - KMP 알고리즘
        - 불일치가 발생한 텍스트 문자열의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
        - 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
            ```c++
            void kmp(char *pattern){
                int n = strlen(pattern);
                int i = -1; int j = 0;
                next[j] = i;
                while(j<n){
                    if(i == -1 || (i >= 0 && pattern[i] == pattern[j])){
                        i++; j++; next[j] = i;
                    }
                    else i = next[i];
                }
            }
            ```
        - 시간 복잡도: O(N+M)
            
    - 보이어-무어 알고리즘
        - 오른쪽에서 왼쪽으로 비교
        - 대부분의 상용 소프트웨어 채택
        - 패턴의 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이만큼 된다
        - 불일치한 문자가 패턴에 존재하는 경우, 실제 존재하는 거리만큼만 이동한다
        - skip table
            
            ```c++
            void makeSkipTable(char key[]){
                int k; int n;
                n = strlen(key);
                for(k=0; k<n; k++){
                    skip[key[k]] = k;
                }
            }
            n = strlen(ori);
            m = strlen(search);
            int i = m-1; int j = m-1;
            while(i<n){
                if(ori[i] == search[j]){
                    if(j==0){
                        i += m;
                        j = m-1;
                    }
                    else{
                        i--; j--;
                    }
                }
                else{
                    i += m - skip[ori[i]];
                    j = m - 1;
                }
            }
            ```