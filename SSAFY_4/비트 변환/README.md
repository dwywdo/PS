#### 비트 변환
---
+ 0, 1로 이루어진 N개의 숫자로 만든 수열이 주어진다. 여기서 2가지 중 하나의 행동을 할 수 있다.

    + 두 숫자의 위치를 바꾼다  (Swap)
    + 하나의 숫자를 0 또는 1로 바꾼다 (Switch)

+ 우리가 가진 수열과 원하는 수열이 주어질 때, 원하는 수열을 만들기 위해 최소 몇 번의 행동을 해야 하는지 구하여라

    + 예시)

        ```
        01100 -> 01010
        정답: 1회 (3번째와 4번째 비트를 Swap)
        ```

##### 문제 접근
---
+ 우리가 가진 수열을 시작 수열, 원하는 수열을 종료 수열이라 할 때

  + 같은 위치에 있는 비트가 동일한 값이면 건드려 줄 필요가 없다
  + 같은 위치에 있는 비트가 다른 값이면 두 가지 행동 중 하나를 통해 바꾸어주어야 함

  

+ **최솟값**을 구하는 것

  + Swap 연산의 경우, 적절하게 사용하면 두 개의 비트를 한번에 원하는 조건에 맞출 수 있음
  + Switch 연산은 한 번에 한 개의 비트만을 원하는 조건에 맞출 수 있음
  + 최솟값이 되려면, Swap 연산이 우선해야겠다.
  + 다만, Swap 연산을 적절한 경우에만 사용해야 최적의 값을 구할 수 있다.
    + 언제가 적절한건데? 두 비트의 값이 0, 1이고, 두 비트의 위치가 모두 값이 반전되어야 할 상황일 때!
    + 이를 알기 위해 **XOR 연산**을 이용할 것이다

  

+ 먼저 바꾸어 주어야 하는 비트의 위치들을 알기 위해, **XOR 연산**을 수행한다

  + XOR 연산? 비트 연산 중의 하나로, 각 비트의 값이 다르면 1, 동일하면 0을 반환하는 연산

  + 예시)

    ```
    01100 XOR 01010 = 00110
    
        01100
    XOR 01010
    ---------
        00110
    ```

    + 바꾸어 주어야 할 비트들의 위치를 파악했으면, 시작 수열과 함께 나열하여 본다

      ```
      01100 (시작수열)
      00110 (XOR 결과)
      ```

    + XOR 결과를 기준으로 보면서, 시작수열의 0과 1을 짝지어 준다 (두 숫자의 위치를 바꾸는 연산)

      ```
      01100
      00110
      
      하나의 짝이 나옴 -> 한번의 Swap 연산 후면 XOR 결과는 00000 -> 종료 수열에 도달
      ```

    + 모두 짝지어 준 후에, 짝지어지지 않은 비트는 0->1, 1->0으로 바꿔서 종료 수열과 값을 같게 맞추어 준다

      + 이게 Switch 연산을 의미하는 것
      + 짝지어지지 않은 비트는 종료 수열과 값이 다르지만 다른 위치로부터 Swap 해올 값이 없는 것들을 의미하고, 이는 Switch로 값을 직접 바꾸어 주는 수밖에 없다.

  

+ 문제 4번 풀이

  ```
  시작 수열: 10111001101
  종료 수열: 10111101000
  
  1. XOR 연산 수행
      10111001101
  XOR 10111101000
  ---------------
      00000100101
  
  2. 시작 수열과 XOR 결과 비교
  
  10111001101
  00000100101
  
  3. XOR결과의 1값들을 보면서 시작수열의 0,1 값을 기준으로 짝짓기
  
  0 1 2 3 4 5 6 7 8 9 10 (위치 표현)
  1 0 1 1 1 0 0 1 1 0  1
  0 0 0 0 0 1 0 0 1 0  1
  
  5, 8번째 비트가 XOR결과는 1이면서 시작 수열의 값은 0,1 -> 짝 하나 (Swap 연산 1번)
  10번째 비트는 짝지을 게 없으므로 바꾸어 준다(Switch 연산 1번)
  
  -> 답 : 2회 (Swap 1, Switch 1)
  ```

  

+ 문제 5번 풀이

  ```
  시작 수열: 1111010101010101010
  종료 수열: 0100101011011010101
  
  1. XOR 연산 수행
      1111010101010101010
  XOR 0100101011011010101
  -----------------------
      1011111110001111111
      
  
  2. 시작 수열과 XOR 결과 비교
  
  1111010101010101010
  1011111110001111111
  
  3. XOR결과의 1값들을 보면서 시작수열의 0,1 값을 기준으로 짝짓기
  
  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 (위치 표현)
  1 1 1 1 0 1 0 1 0 1  0  1  0  1  0  1  0  1  0
  1 0 1 1 1 1 1 1 1 0  0  0  1  1  1  1  1  1  1
  
  짝짓기 결과
  (0, 4)
  (2, 6)
  (3, 8)
  (5, 12)
  (7, 14)
  (13, 16)
  (15, 18)
  
  총 7번의 Swap 후, 17번째 비트는 짝지어지지 않는다(Switch 연산)
  
  -> 답: 8회 (Swap 7, Switch 1)
  ```

  

##### 결론

---

+ 왜 최솟값이 되는지는 저번 전구 스위치와 유사하게 생각할 수 있음

  + 하나의 비트는 안바꾸거나, 바꾸거나 둘 중 하나임 2번 이상 조작이 가해질 필요가 없음
  + 연산의 종류가 두 가지지만, 최솟값을 만족하기 위해서는 Swap을 우선적으로 고려해야 함
  + Swap 연산을 의미없이 사용하면 최솟값이 나오지 않을 것임
    + 꼭 필요한 경우에만 사용하기 위해 XOR 연산 활용하여 어디에 Swap 연산을 적용해야 할지 짝짓기로 확인 가능

  + Swap 연산으로 처리할 수 없는 비트들의 경우에만 Switch 연산으로 값 변경